{"ast":null,"code":"import { createElementVNode as _createElementVNode, toDisplayString as _toDisplayString, openBlock as _openBlock, createElementBlock as _createElementBlock, pushScopeId as _pushScopeId, popScopeId as _popScopeId } from \"vue\";\n\nconst _withScopeId = n => (_pushScopeId(\"data-v-fd28126e\"), n = n(), _popScopeId(), n);\n\nconst _hoisted_1 = {\n  class: \"game\"\n};\nconst _hoisted_2 = {\n  class: \"canvas-container\"\n};\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return _openBlock(), _createElementBlock(\"div\", _hoisted_1, [_createElementVNode(\"div\", _hoisted_2, [_createElementVNode(\"canvas\", {\n    ref: \"canvas\",\n    onMousemove: _cache[0] || (_cache[0] = (...args) => $options.moveBasket && $options.moveBasket(...args)),\n    onMousedown: _cache[1] || (_cache[1] = (...args) => $options.catchTreasure && $options.catchTreasure(...args))\n  }, null, 544\n  /* HYDRATE_EVENTS, NEED_PATCH */\n  )]), _createElementVNode(\"p\", null, \"Score: \" + _toDisplayString($data.score), 1\n  /* TEXT */\n  )]);\n}","map":{"version":3,"mappings":";;;;;AACUA,OAAK,EAAC;;;AACJA,OAAK,EAAC;;;uBADbC,oBAKM,KALN,cAKM,CAJJC,oBAEM,KAFN,cAEM,CADJA,oBAAiF,QAAjF,EAAiF;AAAzEC,OAAG,EAAC,QAAqE;AAA3DC,eAAS,yCAAEC,mDAAF,CAAkD;AAAnCC,eAAS,yCAAED,yDAAF;AAA0B,GAAjF;;AAAA,GACI,CAFN,CAII,EADJH,oBAAyB,GAAzB,EAAyB,IAAzB,EAAG,YAAOK,iBAAGC,WAAH,CAAV,EAAkB;AAAA;AAAlB,GACI,CALN","names":["class","_createElementBlock","_createElementVNode","ref","onMousemove","$options","onMousedown","_toDisplayString","$data"],"sourceRoot":"","sources":["C:\\Users\\kk\\Desktop\\Web\\Web-Project\\vuejs\\game-master\\src\\components\\menus\\TreasurePage.vue"],"sourcesContent":["<template>\r\n     <div class=\"game\">\r\n       <div class=\"canvas-container\">\r\n         <canvas ref=\"canvas\" @mousemove=\"moveBasket\" @mousedown=\"catchTreasure\"></canvas>\r\n       </div>\r\n       <p>Score: {{ score }}</p>\r\n     </div>\r\n   </template>\r\n   \r\n   <script>\r\n   export default {\r\n     data() {\r\n       return {\r\n         canvas: null,\r\n         ctx: null,\r\n         width: 0,\r\n         height: 0,\r\n         basket: {\r\n           x: 0,\r\n           y: 0,\r\n           width: 50,\r\n           height: 50,\r\n         },\r\n         treasures: [],\r\n         score: 0,\r\n       };\r\n     },\r\n     mounted() {\r\n       this.canvas = this.$refs.canvas;\r\n       this.ctx = this.canvas.getContext('2d');\r\n       this.width = this.canvas.width;\r\n       this.height = this.canvas.height;\r\n       this.initTreasures();\r\n       this.draw();\r\n     },\r\n     methods: {\r\n       initTreasures() {\r\n         const numTreasures = 10;\r\n         for (let i = 0; i < numTreasures; i++) {\r\n           const treasure = {\r\n             x: Math.random() * (this.width - 50),\r\n             y: Math.random() * (this.height - 50),\r\n             width: 30,\r\n             height: 30,\r\n             collected: false,\r\n           };\r\n           this.treasures.push(treasure);\r\n         }\r\n       },\r\n       draw() {\r\n         this.ctx.clearRect(0, 0, this.width, this.height);\r\n         for (const treasure of this.treasures) {\r\n           if (!treasure.collected) {\r\n             this.ctx.fillStyle = 'gold';\r\n             this.ctx.fillRect(treasure.x, treasure.y, treasure.width, treasure.height);\r\n           }\r\n         }\r\n         this.ctx.fillStyle = 'blue';\r\n         this.ctx.fillRect(this.basket.x, this.basket.y, this.basket.width, this.basket.height);\r\n         requestAnimationFrame(this.draw);\r\n       },\r\n       moveBasket(event) {\r\n         const rect = this.canvas.getBoundingClientRect();\r\n         const offsetX = event.clientX - rect.left;\r\n         const offsetY = event.clientY - rect.top;\r\n         this.basket.x = offsetX - this.basket.width / 2;\r\n         this.basket.y = offsetY - this.basket.height / 2;\r\n       },\r\n       catchTreasure() {\r\n         for (const treasure of this.treasures) {\r\n           if (!treasure.collected && this.isCollision(this.basket, treasure)) {\r\n             treasure.collected = true;\r\n             this.score++;\r\n           }\r\n         }\r\n       },\r\n       isCollision(rect1, rect2) {\r\n         return (\r\n           rect1.x < rect2.x + rect2.width &&\r\n           rect1.x + rect1.width > rect2.x &&\r\n           rect1.y < rect2.y + rect2.height &&\r\n           rect1.y + rect1.height > rect2.y\r\n         );\r\n       },\r\n     },\r\n   };\r\n   </script>\r\n   \r\n   <style scoped>\r\n   .canvas-container {\r\n     position: relative;\r\n     width: 600px;\r\n     height: 400px;\r\n     border: 1px solid #000;\r\n   }\r\n   \r\n   canvas {\r\n     border: 1px solid #000;\r\n   }\r\n   \r\n   .game {\r\n     display: flex;\r\n     flex-direction: column;\r\n     align-items: center;\r\n   }\r\n   </style>"]},"metadata":{},"sourceType":"module"}